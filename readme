##################################
#### start from these files 
config.dk: include most of the paths of input/output files, parameters to use in the program. 
           used by Yu in Denmark, to test data mapped to hg19.
                  (@C: means mentioned parameters can be found in this config file)
qsub_dk.py: call programs or write commands to submit to cluster
	    most program has input like this:
            debug/program_to_call config.dk (option) (pn_idx)
	    eg: "debug/alu_insert config.dk alu_mate_flag 0" call alu_insert with 
                option "alu_mate_flag" for the 0th PN in the (@C)file_pn

config.decode: used by Yu in Iceland, where the old files sitting 

##################################
#### alu deletion 
1. build_dist.cpp
   /** create probability density function of insert length for each PN, stratified by reading group
       */
   results written into: (@C)file_dist_prefix 

2. alu_delete.cpp
   /** reads are classified as mid reads (cross alu region, indication of no deletion), clip reads (clip mapped at alu boundary, indication of 
       deletion) and unknown reads (can't know for sure if it is mid or clip read, use insert length instead) .   
       */
   opt = write_tmp1: 
       write temporary results: (@C)file_alu_delete0
       generate *log1: high coverage region
       generate *tmp1: counts of 3 types of read, and insert length for unknow reads. 

   opt = write_tmp2: 
       generate *tmp2: calculte genotype prob based on *tmp1 files. 
                       header l0, l1, l2: genotype prob based on mid/clip reads
                       header m0, m1, m2: genotype prob based on mid/clip/unknow reads

   opt = write_vcf:
       write final results: (@C)file_alu_delete0
       mutation that is private (only 1 individual has) is ignore. 
       generate *vcf and *pos files: as before, "lr" used mid/clip reads,  "mr" used mid/clip/unknow reads
       filter good quality mutations using *pos file.
       
   opt = debug:
       debug purpose
       
##################################
#### alu insertion (3 steps: alu_insert.cpp, insert_pos.cpp, ins_del.cpp)
1. alu_insert.cpp 
   opt = "alu_mate_flag": 
       write results: (@C)file_alu_insert0
       for each pn, scan the genome and find potention loci for alu insertion, this generate a lot of temporary files. 
       *tmp1, *tmp2 and *tmp3 files can be ignored after this step
       *tmp1, reads mapped at dif chrn or far away
       *tmp2, subset of *tmp1, where one end is mapped to alu 
              keep_alu_mate(), read_sort_by_col(tmp1)
       *tmp3, rewrite *tmp2 and sort rows by position, read_sort_by_col()
       *tmp4, subset of *tmp3, where only left_alu_cnt + right_alu_cnt >= 4 is considered. 
       *tmp4st, subset of *tmp4, with pos in repetitive regions are excluded 
       
   opt = "combine_pn_pos" :
        write results: (@C)file_alu_insert1
        find common insertion positions of multiple individuals
        Note: some PNs with extreme large amount of reads (that might be alu mate). (almost 10 times of other PNs)
              eg: MXQBTEO, HYKJEJS, EIVHBDQ, KSRDJGR
              EITHER:  > 4G memory to fun; OR: ignore them
              I chose to ignore them. For each chromosome, 15% individuals with extremely high potential insert positions are ignored. 
              (search 0.85 in alu_insert.cpp in order to modify this number)
	
2. insert_pos.cpp
   this file find the exact insertion positions (insertBegin, insertEnd) ==> needs improvement

   opt = "1":
     only insertions with freq in [minfreq, maxfreq] are considered, eg [0.02, 1]
     for each pn, write the broken reads at these insertion positions to files at (@C)file_clip_reads/chr1/pn_minfreq_maxfreq.
     This information will be used to infer exact insertion positions later. 

   opt = "2":
     write files at  (@C)file_clip_reads/chr1_pos/regionBegin_regionEnd
     all broken reads with insertion between regionBegin and regionEnd are written into corresponding files. 
   opt = "3":
     exact position is written at (@C)file_alu_insert1/chr1_0.02_1.tmp
     exact position with more details: (@C)file_alu_insert1/chr1_0.02_1
             
   opt = "debug":
     for debugging       

3. ins_del.cpp
   
   opt = "write_tmp1":
       write *tmp1 files, which are similar to *tmp1 files at 

   opt = "write_tmp2":
       to be implemented (small modification based on alu_delete)

   opt = "debug":
       for some debugging 

   opt = "write_testbam":
       write small test bam files 
      
